:: sexHelpers [script]

setup.getRoomFurnitureFlags = function (roomKey) {
    const room = setup.RoomTypes.db[roomKey];
    if (!room) return [];

    const flags = [];

    Object.keys(room.contents).forEach(furnKey => {
        const furn = setup.RoomTypes.furniture[furnKey];
        if (furn && furn.flags) {
            flags.push(...furn.flags);
        }
    });

    return [...new Set(flags)];
};

setup.syncSexWithRoom = function (sex, room) {
    sex.location = room.location;
    sex.furnitureFlags = room.furnitureFlags;
};


setup.partAliases = {
    asshole: "anus",
    ass: "butt",
    breasts: "chest",
    tits: "breasts",
    feet: "foot"
};

setup.normalizeBodyparts = function(actor) {
    if (!actor || !actor.body) return;

    const parts = Object.keys(actor.body);

    if (actor.genitals) {
        parts.push(actor.genitals);
    }

    actor.bodyparts = [...new Set(parts)];
};

setup.getEncounterSize = function (sex) {
    let count = 0;
    if (sex.subject) count++;
    if (sex.object) count++;

    if (Array.isArray(sex.participants)) {
        count += sex.participants.length;
    }

    return count;
};

setup.partEquals = function (a, b) {
    if (!a || !b) return false;
    return a.localeCompare(b, undefined, { sensitivity: "accent" }) === 0;
};

setup.partMatches = function(actor, required) {
    if (!actor || !actor.bodyparts || !required) return false;

    const req = required.toLowerCase();

    return actor.bodyparts.some(p => {
        const part = p.toLowerCase();
        return (
            part === req ||
            setup.partAliases[part] === req
        );
    });
};

setup.hasParts = function(actor, parts) {
    if (!actor || !actor.bodyparts) return false;
    if (!parts || parts.length === 0) return true;

    return parts.some(p => setup.partMatches(actor, p));
};


setup.isPositionValid = function (positionKey, sex) {
    const pos = setup.sexpositions[positionKey];
    if (!pos) return false;

    const subject = sex.subject;
    const object  = sex.object;

    const topParts = pos.top || [];
    const bottomParts = pos.bottom || [];

    let bodyOK = false;

    if (pos.equal) {
        bodyOK =
            (topParts.some(p => setup.partMatches(subject, p)) &&
             bottomParts.some(p => setup.partMatches(object, p))) ||
            (topParts.some(p => setup.partMatches(object, p)) &&
             bottomParts.some(p => setup.partMatches(subject, p)));
    }
    else if (sex.role === "top") {
        bodyOK =
            topParts.some(p => setup.partMatches(subject, p)) &&
            bottomParts.some(p => setup.partMatches(object, p));
    }
    else if (sex.role === "bottom") {
        bodyOK =
            topParts.some(p => setup.partMatches(object, p)) &&
            bottomParts.some(p => setup.partMatches(subject, p));
    }

    if (!bodyOK) return false;

    if (pos.furniture?.length) {
        if (!sex.furnitureFlags?.length) return false;
        if (!pos.furniture.some(f => sex.furnitureFlags.includes(f))) {
            return false;
        }
    }

    return true;
};



setup.getAvailablePositions = function (sex) {
    const size = setup.getEncounterSize(sex);

    return Object.keys(setup.sexpositions)
        .filter(posKey => {
            const pos = setup.sexpositions[posKey];

            // 1-on-1 encounter → primary only
            if (size <= 2) {
                return pos.primary === true;
            }

            // Multi-partner → primary + secondary
            return pos.primary === true || pos.secondary === true;
        })
        .filter(posKey => setup.isPositionValid(posKey, sex));
};



setup.actAllowsPosition = function(act, sex) {
    if (!act.positions || !Array.isArray(act.positions)) return true;

    return act.positions.some(p => {
        const [pos, role] = p.split(":");
        if (pos !== sex.position) return false;
        if (!role) return true;
        if (role === sex.role) return true;
        if (sex.role === "equal") return true;
        return false;
    });
};




setup.getAvailableSexActs = function (sex) {
    return Object.entries(setup.sexacts)
        .filter(([_, act]) => {
            const types = act["action type"];

            // END acts: special handling
            if (types.includes("end")) {
                return (
                    sex.phase === "continue" &&
                    setup.isEndActValid(act, sex)
                );
            }

            // Normal phase logic
            const allowed = setup.getAllowedActTypesForPhase(sex.phase);
            if (!types.some(t => allowed.includes(t))) return false;

            if (!setup.actAllowsPosition(act, sex)) return false;
            if (!setup.hasParts(sex.subject, act["subject parts"])) return false;
            if (!setup.hasParts(sex.object, act["object parts"])) return false;

            return true;
        })
        .map(([name]) => name);
};


setup.applySexAct = function (sex, actKey) {
    if (!sex || !actKey) return;

    if (!Array.isArray(sex.history)) {
        sex.history = [];
    }

    const act = setup.sexacts[actKey];
    if (!act) return;

    sex.history.push(actKey);
    sex.act = actKey;


    const types = act["action type"];

    // END always wins
    if (types.includes("end")) {
        sex.penetration = null;
        sex.phase = "tease";
        return;
    }

    // PENETRATION starts penetration & moves to continue
    if (types.includes("penetrate")) {
        sex.penetration = {
            subjectPart: act["subject parts"] && act["subject parts"][0] ? act["subject parts"][0] : null,
            objectPart: act["object parts"] && act["object parts"][0] ? act["object parts"][0] : null

        };
        sex.phase = "continue";
        return;
    }

    // CONTINUE keeps penetration going
    if (types.includes("continue")) {
        sex.phase = "continue";
        return;
    }

    // TEASE keeps tease phase
    if (types.includes("tease")) {
        sex.phase = "tease";
    }
};


setup.getAllowedActTypesForPhase = function (phase) {
    switch (phase) {
        case "tease":
            return ["tease", "penetrate"];
        case "continue":
            return ["continue", "end"];
        default:
            return ["tease"];
    }
};

setup.roomHasFurniture = function (sex, required) {
    if (!required || required.length === 0) return true;
    if (!sex.furnitureFlags) return false;

    return required.some(f => sex.furnitureFlags.includes(f));
};

setup.ensureValidSexPosition = function (sex) {
    const available = setup.getAvailablePositions(sex) || [];

    // No valid positions at all
    if (available.length === 0) {
        sex.position = null;
        sex.act = null;
        sex.penetration = null;
        sex.phase = "tease";
        return;
    }

    // Current position still valid → do nothing
    if (sex.position && available.includes(sex.position)) {
        return;
    }

    // Otherwise, force fallback
    sex.position = available[0];
    sex.act = null;
    sex.penetration = null;
    sex.phase = "tease";
};


setup.isEndActValid = function (act, sex) {
    if (!sex || !sex.penetration) return false;
    if (!sex.penetration.subjectPart || !sex.penetration.objectPart) return false;

    const sp = sex.penetration.subjectPart;
    const op = sex.penetration.objectPart;

    const aSub = act["subject parts"]?.[0];
    const aObj = act["object parts"]?.[0];

    if (!aSub || !aObj) return false;

    if (aSub === sp && aObj === op) return true;
    if (aSub === op && aObj === sp) return true;

    return false;
};

