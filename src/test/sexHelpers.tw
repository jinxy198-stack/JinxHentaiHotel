:: sexHelpers [script]

/*
 * Applies arousal changes from a sex act to the current subject and object.
 * Respects optional arousal caps defined on the act.
 * Safely initializes arousal values if missing.
 */
setup.applyArousalFromAct = function (sex, act) {
  if (!sex || !act) return;

  const subject = sex.subject;
  const object  = sex.object;
  if (!subject || !object) return;

  // Ensure arousal values exist and are numeric
  if (typeof subject.arousal !== "number") subject.arousal = 0;
  if (typeof object.arousal  !== "number") object.arousal  = 0;

  // Apply subject arousal, respecting optional cap
  if (typeof act["subject arousal"] === "number") {
    const cap = act["subject arousal cap"];
    if (cap === undefined || subject.arousal < cap) {
      subject.arousal += act["subject arousal"];
    }
  }

  // Apply object arousal, respecting optional cap
  if (typeof act["object arousal"] === "number") {
    const cap = act["object arousal cap"];
    if (cap === undefined || object.arousal < cap) {
      object.arousal += act["object arousal"];
    }
  }
};

/*
 * Updates the NPC arousal UI elements (progress bar + numeric text).
 * Fails safely if elements are missing.
 */
setup.updateNpcArousalUI = function (value) {
  const bar = document.getElementById("npc-arousal-bar");
  const text = document.getElementById("npc-arousal-text");
  if (bar) bar.value = value;
  if (text) text.textContent = value;
};

/*
 * Determines which actor is considered "top" and "bottom"
 * based on the current position and role.
 * Returns an object: { topActor, bottomActor }
 */
setup.getTopBottomActors = function (sex, pos) {
    let topActor = null;
    let bottomActor = null;

    // Equal positions rely entirely on role
    if (pos.equal) {
        if (sex.role === "top") {
            topActor = sex.subject;
            bottomActor = sex.object;
        } else if (sex.role === "bottom") {
            topActor = sex.object;
            bottomActor = sex.subject;
        }
    } 
    // Non-equal positions still follow role assignment
    else {
        if (sex.role === "top") {
            topActor = sex.subject;
            bottomActor = sex.object;
        } else if (sex.role === "bottom") {
            topActor = sex.object;
            bottomActor = sex.subject;
        }
    }

    return { topActor, bottomActor };
};

/*
 * Updates valid cum locations for subject and object
 * based on the current sex position and role.
 */
setup.updateCumLocations = function (sex) {
    if (!sex || !sex.position) {
        sex.subject.cumLocation = [];
        sex.object.cumLocation = [];
        return;
    }

    const pos = setup.sexpositions[sex.position];
    if (!pos) {
        sex.subject.cumLocation = [];
        sex.object.cumLocation = [];
        return;
    }

    const top = Array.isArray(pos["top cum locations"]) ? pos["top cum locations"] : [];
    const bottom = Array.isArray(pos["bottom cum locations"]) ? pos["bottom cum locations"] : [];

    // Equal role gets combined options
    if (sex.role === "equal") {
        sex.subject.cumLocation = [...new Set([...top, ...bottom])];
        sex.object.cumLocation  = [...new Set([...top, ...bottom])];
        return;
    }

    // Role-based assignment
    if (sex.role === "top") {
        sex.subject.cumLocation = [...top];
        sex.object.cumLocation  = [...bottom];
        return;
    }

    if (sex.role === "bottom") {
        sex.subject.cumLocation = [...bottom];
        sex.object.cumLocation  = [...top];
        return;
    }

    // Fallback
    sex.subject.cumLocation = [];
    sex.object.cumLocation  = [];
};

/*
 * Collects all furniture flags present in a room.
 * Used for validating positions and acts.
 */
setup.getRoomFurnitureFlags = function (roomKey) {
    const room = setup.RoomTypes.db[roomKey];
    if (!room) return [];

    const flags = [];

    Object.keys(room.contents).forEach(furnKey => {
        const furn = setup.RoomTypes.furniture[furnKey];
        if (furn && furn.flags) {
            flags.push(...furn.flags);
        }
    });

    return [...new Set(flags)];
};

/*
 * Synchronizes sex state with the current room context.
 */
setup.syncSexWithRoom = function (sex, room) {
    sex.location = room.location;
    sex.furnitureFlags = room.furnitureFlags;
};


/*
 * Builds a normalized bodyparts list for an actor,
 * including genitals if present.
 */
setup.normalizeBodyparts = function(actor) {
    if (!actor || !actor.body) return;

    const parts = Object.keys(actor.body);

    if (actor.genitals) {
        parts.push(actor.genitals);
    }

    actor.bodyparts = [...new Set(parts)];
};

/*
 * Returns total number of participants in the encounter.
 */
setup.getEncounterSize = function (sex) {
    let count = 0;
    if (sex.subject) count++;
    if (sex.object) count++;

    if (Array.isArray(sex.participants)) {
        count += sex.participants.length;
    }

    return count;
};

/*
 * Case-insensitive body part equality check.
 */
setup.partEquals = function (a, b) {
    if (!a || !b) return false;
    return a.localeCompare(b, undefined, { sensitivity: "accent" }) === 0;
};

/*
 * Checks if an actor has a required body part,
 * accounting for aliases.
 */
setup.partMatches = function(actor, required) {
    if (!actor || !actor.bodyparts || !required) return false;

    const req = required.toLowerCase();

    return actor.bodyparts.some(p => {
        const part = p.toLowerCase();
        return (
            part === req 
        );
    });
};

/*
 * Checks whether an actor has at least one
 * of the required body parts.
 */
setup.hasParts = function(actor, parts) {
    if (!actor || !actor.bodyparts) return false;
    if (!parts || parts.length === 0) return true;

    return parts.some(p => setup.partMatches(actor, p));
};

/*
 * Validates whether a sex position can be used
 * given body parts, roles, and furniture constraints.
 */
setup.isPositionValid = function (positionKey, sex) {
    const pos = setup.sexpositions[positionKey];
    if (!pos) return false;

    const subject = sex.subject;
    const object  = sex.object;

    const topParts = pos.top || [];
    const bottomParts = pos.bottom || [];

    let bodyOK = false;

    if (pos.equal) {
        bodyOK =
            (topParts.some(p => setup.partMatches(subject, p)) &&
             bottomParts.some(p => setup.partMatches(object, p))) ||
            (topParts.some(p => setup.partMatches(object, p)) &&
             bottomParts.some(p => setup.partMatches(subject, p)));
    }
    else if (sex.role === "top") {
        bodyOK =
            topParts.some(p => setup.partMatches(subject, p)) &&
            bottomParts.some(p => setup.partMatches(object, p));
    }
    else if (sex.role === "bottom") {
        bodyOK =
            topParts.some(p => setup.partMatches(object, p)) &&
            bottomParts.some(p => setup.partMatches(subject, p));
    }

    if (!bodyOK) return false;

    if (pos.furniture?.length) {
        if (!sex.furnitureFlags?.length) return false;
        if (!pos.furniture.some(f => sex.furnitureFlags.includes(f))) {
            return false;
        }
    }

    return true;
};

/*
 * Returns all valid sex positions for the current encounter.
 * Filters by encounter size and position validity.
 */
setup.getAvailablePositions = function (sex) {
    const size = setup.getEncounterSize(sex);

    return Object.keys(setup.sexpositions)
        .filter(posKey => {
            const pos = setup.sexpositions[posKey];

            if (size <= 2) {
                return pos.primary === true;
            }

            return pos.primary === true || pos.secondary === true;
        })
        .filter(posKey => setup.isPositionValid(posKey, sex));
};

/*
 * Checks whether an act is allowed in the current position and role.
 */
setup.actAllowsPosition = function(act, sex) {
    if (!act.positions || !Array.isArray(act.positions)) return true;

    return act.positions.some(p => {
        const [pos, role] = p.split(":");
        if (pos !== sex.position) return false;
        if (!role) return true;
        if (role === sex.role) return true;
        if (sex.role === "equal") return true;
        return false;
    });
};

/*
 * Returns all valid sex acts for the current state.
 * Handles phase logic, end acts, body parts, and position constraints.
 */
setup.getAvailableSexActs = function (sex) {
    return Object.entries(setup.sexacts)
        .filter(([_, act]) => {
            const types = act["action type"];

            if (types.includes("end")) {
                return (
                    sex.phase === "continue" &&
                    setup.isEndActValid(act, sex)
                );
            }

            const allowed = setup.getAllowedActTypesForPhase(sex.phase);
            if (!types.some(t => allowed.includes(t))) return false;

            if (!setup.actAllowsPosition(act, sex)) return false;
            if (!setup.hasParts(sex.subject, act["subject parts"])) return false;
            if (!setup.hasParts(sex.object, act["object parts"])) return false;

            return true;
        })
        .map(([name]) => name);
};

/*
 * Applies a selected sex act and updates encounter state.
 */
setup.applySexAct = function (sex, actKey) {
    const act = setup.sexacts[actKey];
    if (!act) return;

    sex.history.push(actKey);
    sex.act = actKey;

    setup.applyArousalFromAct(sex, act);

    const types = act["action type"];

    if (types.includes("end")) {
        sex.penetration = null;
        sex.phase = "tease";
        setup.updateCumLocations(sex);
        return;
    }

    if (types.includes("penetrate")) {
        sex.penetration = {
            subjectPart: act["subject parts"]?.[0] ?? null,
            objectPart: act["object parts"]?.[0] ?? null
        };
        sex.phase = "continue";
        setup.updateCumLocations(sex);
        return;
    }

    if (types.includes("continue")) {
        sex.phase = "continue";
        setup.updateCumLocations(sex);
        return;
    }

    if (types.includes("tease")) {
        sex.phase = "tease";
        setup.updateCumLocations(sex);
    }

    setup.updateBindings();
};

/*
 * Checks whether an actor has reached orgasm threshold.
 */
setup.checkOrgasm = function (actor) {
    return actor.arousal >= 1000;
};

/*
 * Returns which act types are allowed for a given phase.
 */
setup.getAllowedActTypesForPhase = function (phase) {
    switch (phase) {
        case "tease":
            return ["tease", "penetrate"];
        case "continue":
            return ["continue", "end"];
        default:
            return ["tease"];
    }
};

/*
 * Checks if the current room contains required furniture.
 */
setup.roomHasFurniture = function (sex, required) {
    if (!required || required.length === 0) return true;
    if (!sex.furnitureFlags) return false;

    return required.some(f => sex.furnitureFlags.includes(f));
};

/*
 * Ensures the current sex position remains valid.
 * Falls back to the first valid position if needed.
 */
setup.ensureValidSexPosition = function (sex) {
    const available = setup.getAvailablePositions(sex) || [];

    if (available.length === 0) {
        sex.position = null;
        sex.act = null;
        sex.penetration = null;
        sex.phase = "tease";
        return;
    }

    if (sex.position && available.includes(sex.position)) {
        setup.updateCumLocations(sex);
        return;
    }

    sex.position = available[0];
    sex.act = null;
    sex.penetration = null;
    sex.phase = "tease";
    setup.updateCumLocations(sex);
};

/*
 * Validates whether an END act correctly matches
 * the current penetration configuration.
 */
setup.isEndActValid = function (act, sex) {
    if (!sex || !sex.penetration) return false;
    if (!sex.penetration.subjectPart || !sex.penetration.objectPart) return false;

    const sp = sex.penetration.subjectPart;
    const op = sex.penetration.objectPart;

    const aSub = act["subject parts"]?.[0];
    const aObj = act["object parts"]?.[0];

    if (!aSub || !aObj) return false;

    if (aSub === sp && aObj === op) return true;
    if (aSub === op && aObj === sp) return true;

    return false;
};
